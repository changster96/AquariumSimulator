<!DOCTYPE html>
<html>
<body>

<canvas id="myCanvas">
Your browser does not support the canvas element.
</canvas>

<style>
html, body {
  width:  100%;
  height: 100%;
  margin: 0px;
  overflow: hidden;
}
</style>

<script>

function Donut(x, y) {

	this.type = "Donut";
	
	this.x = x;
	this.y = y;
	this.mass = 10;
	
	this.move = function() {
		// Attempts movement, environment permitting
		return [0, 100];
	}
	
	this.draw = function() {
		ctx.strokeStyle = "#880000";
		ctx.beginPath();
		ctx.arc( this.x , this.y , 3 , 0 , 2 * Math.PI);
		ctx.stroke();
	}
}

function Fish(x, y, dx, dy) {
	
	this.type = "Fish";
	
	this.x = x;
	this.y = y;
	this.dx = 0;
	this.dy = 0;
	this.ddx = 0;
	this.ddy = 0;
	
	this.eyesight = 250 + Math.random() * 250;
	this.hunger = Math.random() * 10000;
	this.socialness = Math.random() * 100 - 50;
	this.danger_sense = Math.random() * 10000;
	this.top_accel = Math.random() * 1000 + 1000;
	this.mass = Math.random() * 30 + 30
	
	this.move = function() {
		// Attempts movement
		
		this.dx *= 0.95;
		this.dy *= 0.95;
		if (this.mass > 100) {this.mass *= 0.999;}
		
		best_direction = [0, 0];
		
		for (id in entities) {
			x_distance = entities[id].x - this.x;
			y_distance = entities[id].y - this.y;
			
			if (x_distance > window.innerWidth / 2) {
				x_distance = x_distance - window.innerWidth;
			} else if (x_distance < -1 * window.innerWidth / 2) {
				x_distance = x_distance + window.innerWidth;
			}
			
			if (y_distance > window.innerHeight / 2) {
				y_distance = y_distance - window.innerHeight;
			} else if (y_distance < -1 * window.innerHeight / 2) {
				y_distance = y_distance + window.innerHeight;
			}
			
		    distance = Math.sqrt(Math.pow(x_distance, 2) +
				                 Math.pow(y_distance, 2));
								 
			if ((distance > 0) && (distance < this.eyesight)) {
				if ((entities[id].type == "Donut") || (entities[id].mass < this.mass / 2)) {
					// target is edible!
					
					best_direction[0] += (x_distance) * entities[id].mass / distance * this.hunger;
					best_direction[1] += (y_distance) * entities[id].mass / distance * this.hunger;
				} else if ((entities[id].mass > this.mass / 2) && (entities[id].mass < this.mass * 2) && (entities[id].mass != this.mass)) {
					// target is just there I guess
					
					best_direction[0] += (x_distance) * this.socialness / distance;
					best_direction[1] += (y_distance) * this.socialness / distance;
				}  else {
					// target can eat this!
					
					best_direction[0] += -1 * (x_distance) * Math.sqrt(entities[id].mass) / distance * this.danger_sense;
					best_direction[1] += -1 * (y_distance) * Math.sqrt(entities[id].mass) / distance * this.danger_sense;
				}
			}
		}
		
		
		
		
		best_direction_power = Math.sqrt(Math.pow(best_direction[0], 2) + 
										 Math.pow(best_direction[1], 2));
		if (best_direction_power > this.top_accel) {
			best_direction[0] = best_direction[0] * this.top_accel / best_direction_power;
			best_direction[1] = best_direction[1] * this.top_accel / best_direction_power;
		}
		
		this.ddx = best_direction[0];
		this.ddy = best_direction[1];
		this.dx += this.ddx / Math.sqrt(this.mass) * elapsed_time;
		this.dy += this.ddy / Math.sqrt(this.mass) * elapsed_time;
		
		return [this.dx, this.dy];
		
	}
	
	this.draw = function() {
	
		radius = Math.sqrt(this.mass);
		
		// Determine orientation based on fish's force
		if (this.ddx >= 0) {
			ori = 1;
		} else {
			ori = -1;
		}
		
		var tail = new Path2D();
		tail.moveTo(this.x , this.y);
		tail.lineTo( this.x + radius * -2 * ori, this.y + radius * 1);
		tail.lineTo( this.x + radius * -2 * ori, this.y + radius * -1);
		ctx.fillStyle = "#FF0000";
		ctx.fill(tail);
		
		var tail2 = new Path2D();
		tail2.moveTo(this.x , this.y);
		tail2.lineTo( this.x + radius * -1.8 * ori, this.y + radius * 0.9);
		tail2.lineTo( this.x + radius * -1.8 * ori, this.y + radius * -0.9);
		ctx.fillStyle = "#FFA500";
		ctx.fill(tail2);
		
		var fin = new Path2D();
		fin.moveTo( this.x + radius * -1 * ori, this.y + radius * 1.5);
		fin.lineTo( this.x + radius * -0.5 * ori, this.y + radius * 0);
		fin.lineTo( this.x + radius * -1 * ori, this.y + radius * -1.5);
		fin.lineTo( this.x + radius * 0 * ori, this.y + radius * -1);
		fin.lineTo( this.x + radius * 0 * ori, this.y + radius * 1);
		ctx.fillStyle = "#FFA500";
		ctx.fill(fin);
		
		// Fish head
		ctx.beginPath();
		ctx.arc( this.x , this.y , radius , 0 , 2 * Math.PI );
		ctx.fillStyle = "#FFA500";
		ctx.fill();
		
		// Fish eyeball
		ctx.beginPath();
		ctx.arc( this.x + radius * 0.5 * ori, this.y + radius * -0.5, radius / 4, 0 , 2 * Math.PI );
		ctx.fillStyle = "#FFFFFF";
		ctx.fill();
		
		// Fish pupil
		ctx.beginPath();
		ctx.arc( this.x + radius * 0.6 * ori, this.y + radius * -0.6, radius / 8, 0 , 2 * Math.PI );
		ctx.fillStyle = "#000000";
		ctx.fill();
		
		// Messy? yeah but it works ayee
		
	}
	
}

function update() {

	// get frame time difference
	current_frame_time = new Date();
	elapsed_time = (current_frame_time - last_frame_time) / 1000;

	//move fish
	for (fish in entities) {
		
		attempted_move = entities[fish].move();
		new_x = entities[fish].x + attempted_move[0] * elapsed_time;
		new_y = entities[fish].y + attempted_move[1] * elapsed_time;
		
		entities[fish].x = (new_x + window.innerWidth) % window.innerWidth;
		entities[fish].y = (new_y + window.innerHeight) % window.innerHeight;
		
	}
	
	// collision detection
	for (id_1 in entities) {
		if (entities[id_1].type === "Fish") {
			for (id_2 in entities) {
				if (entities[id_2].mass < entities[id_1].mass / 2) {
					distance = Math.sqrt(Math.pow(entities[id_1].x - entities[id_2].x, 2) +
										 Math.pow(entities[id_1].y - entities[id_2].y, 2));
					if (distance < Math.sqrt(entities[id_1].mass)) {
						// Eaten!
						entities[id_1].mass += entities[id_2].mass;
						entities.splice(id_2, 1);
					}
				}
			}
		}
	}
	
	// clear screen
	ctx.fillStyle = "#334D66";
	ctx.fillRect( 0 , 0 , window.innerWidth , window.innerHeight );
	
	// draw fish
	for (fish in entities) {
		entities[fish].draw();
	}	
	
	last_frame_time = current_frame_time;
	
}

function add_fish() {
	entities.push(new Fish(50, 50, 100, 200));
}

function supply_fish() {

	fish_count = 0;
	for (id in entities) {
		if (entities[id].type === "Fish") {
			fish_count++;
		}
	}
	
	if (fish_count < fish_max_pop) {
		entities.push(new Fish(Math.random() * window.innerWidth,
							   Math.random() * window.innerHeight,
							   0, 0));
	}
	
}

function add_donut() {
	entities.push(new Donut(50, 50))
}

function mouse_down(event) {
	canvas_x = event.x - canvas.offsetLeft;
	canvas_y = event.y - canvas.offsetTop;
	entities.push(new Donut(canvas_x, canvas_y));
}

function random_feed() {
	entities.push(new Donut(Math.random() * window.innerWidth, Math.random() * window.innerHeight))
}

function toggle_autofeeder() {
	if (!auto_feed) {
		auto_feed = setInterval(random_feed, 100);
	} else {
		clearInterval(auto_feed);
		auto_feed = null;
	}

}

var canvas = document.getElementById("myCanvas");
canvas.addEventListener('click', mouse_down, false);
canvas.onmousedown = function(){return false;}; // stops double-click problem
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

var ctx = canvas.getContext("2d");

var entities = [];

var TANK_MARGIN = 25;
var last_frame_time = new Date();

var i = 0;

var updater = setInterval(update, 16)
var fish_adder = setInterval(supply_fish, 10)
var auto_feed = false;

var fish_max_pop = 150;

</script>

</body>
</html>

